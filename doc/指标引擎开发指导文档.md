# 实验室指标引擎开发指导文档

## 版本历史

| 版本 | 日期 | 作者 | 描述 |
|------|------|------|------|
| v1.0 | 2026-01-20 | Claude | 初始版本，基于现有架构设计 |
| v1.1 | 2026-01-27 | Claude | 整合 Indicator 和 Metric 系统，统一使用 Metric |

## ⚠️ 重要说明：Indicator 和 Metric 整合

**更新日期**：2026-01-27

Indicator 和 Metric 系统已整合，统一使用 **Metric** 系统。

### 整合内容
- ✅ **后端**：删除 Indicator 实体、服务、接口，统一使用 Metric
- ✅ **前端**：删除 Indicator 页面和 API，统一使用 Metric
- ✅ **数据库**：创建数据迁移脚本（`sql/migration_merge_indicator_to_metric.sql`）
- ✅ **文档**：统一使用 Metric 术语

### 统一术语
- **指标定义**：使用 `MetricDefinitionEntity`（表：`lab_metric_definition`）
- **指标计算**：使用 `MetricCalculationService`
- **API 端点**：统一使用 `/api/lab/metric-definitions`
- **前端路由**：统一使用 `/lab/metric`

**注意**：本文档中如有提到 Indicator，均指 Metric 系统。

## 一、项目概述

### 1.1 项目背景
当前实验室数据系统在中间数据生成阶段使用硬编码的公式计算（如：`F_ONE_METER_WT = F_FOUR_METER_WT / STD_LENGTH`）。这种设计导致以下问题：
1. **公式修改困难**：需要修改代码并重新部署
2. **缺乏灵活性**：无法根据产品规格动态调整计算公式
3. **维护成本高**：新公式需要开发人员介入

### 1.2 项目目标
在lab模块下新建指标引擎，实现：
1. **可配置的指标定义**：支持动态创建、修改计算公式
2. **变量绑定机制**：支持中间数据表字段、公共维度、常量引用
3. **公式版本管理**：支持公式历史版本追溯
4. **高性能计算**：支持批量数据计算和缓存
5. **与现有系统集成**：无缝集成Excel导入和公共维度系统

### 1.3 核心价值
- **业务灵活性**：业务人员可自主配置计算公式
- **系统可维护性**：降低代码耦合，提高系统可维护性
- **数据一致性**：通过版本管理确保历史数据计算一致性

## 二、整体架构设计

### 2.1 架构图
```
┌─────────────────────────────────────────────────────────────┐
│                        前端界面                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 指标定义管理 │  │ 公式编辑器   │  │ 计算结果展示 │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                       API网关层                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 指标定义API │  │ 计算执行API │  │ 结果查询API │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                     业务逻辑层                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 指标定义服务 │  │ 公式计算引擎 │  │ 变量解析器   │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 版本管理服务 │  │ 缓存管理器   │  │ 依赖分析器   │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                      数据访问层                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 指标定义仓储 │  │ 中间数据仓储 │  │ 公共维度仓储 │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                      数据存储层                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 指标定义表   │  │ 中间数据表   │  │ 公共维度表   │          │
│  │ LAB_INDICATOR│  │ LAB_INTER-  │  │ LAB_PUBLIC_ │          │
│  │ _DEFINITION  │  │ MEDIATE_DATA│  │ DIMENSION   │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心模块划分
1. **指标定义模块**：指标元数据管理
2. **公式引擎模块**：表达式解析和计算
3. **变量绑定模块**：数据源和常量引用
4. **版本管理模块**：公式版本控制
5. **计算执行模块**：批量计算和缓存

### 2.3 与现有系统集成
- **集成Excel导入**：沿用`ExcelImportTemplate`的配置模式
- **利用公共维度**：复用`PublicDimensionEntity`和版本管理
- **扩展中间数据**：在`IntermediateDataService`中集成指标计算
- **保持统一风格**：遵循现有架构模式和命名规范

## 三、数据库设计

### 3.1 指标定义表（LAB_INDICATOR_DEFINITION）
```sql
CREATE TABLE LAB_INDICATOR_DEFINITION (
    F_ID NVARCHAR(50) PRIMARY KEY,
    F_INDICATOR_NAME NVARCHAR(100) NOT NULL,        -- 指标名称（如：一米带材重量）
    F_INDICATOR_CODE NVARCHAR(100) NOT NULL,        -- 指标编码（如：ONE_METER_WT）
    F_DESCRIPTION NVARCHAR(500),                    -- 指标描述
    F_DATA_TYPE NVARCHAR(20) NOT NULL,              -- 数据类型：DECIMAL/INT/TEXT
    F_FORMULA_EXPRESSION NVARCHAR(2000) NOT NULL,   -- 公式表达式
    F_FORMULA_LANGUAGE NVARCHAR(20) NOT NULL,       -- 公式语言：EXCEL/MATH/SCRIPT
    F_CALCULATION_ORDER INT NOT NULL DEFAULT 0,     -- 计算顺序（解决依赖）
    F_UNIT_ID NVARCHAR(50),                         -- 单位ID（关联LAB_UNIT）
    F_PRECISION INT,                                -- 小数位数
    F_IS_ENABLED BIT NOT NULL DEFAULT 1,            -- 是否启用
    F_IS_SYSTEM BIT NOT NULL DEFAULT 0,             -- 是否为系统内置指标
    F_SORTCODE BIGINT,                              -- 排序码
    -- 基础字段（继承CLDEntityBase）
    F_CREATOR_TIME DATETIME,
    F_CREATOR_USER_ID NVARCHAR(50),
    F_LAST_MODIFY_TIME DATETIME,
    F_LAST_MODIFY_USER_ID NVARCHAR(50),
    F_DELETE_MARK INT DEFAULT 0,
    F_DELETE_TIME DATETIME,
    F_DELETE_USER_ID NVARCHAR(50),
    F_TENANTID NVARCHAR(50)
);

CREATE UNIQUE INDEX IDX_INDICATOR_CODE ON LAB_INDICATOR_DEFINITION(F_INDICATOR_CODE, F_TENANTID);
CREATE INDEX IDX_INDICATOR_ENABLED ON LAB_INDICATOR_DEFINITION(F_IS_ENABLED, F_TENANTID);
CREATE INDEX IDX_INDICATOR_ORDER ON LAB_INDICATOR_DEFINITION(F_CALCULATION_ORDER, F_TENANTID);
```

### 3.2 公式变量绑定表（LAB_INDICATOR_VARIABLE）
```sql
CREATE TABLE LAB_INDICATOR_VARIABLE (
    F_ID NVARCHAR(50) PRIMARY KEY,
    F_INDICATOR_ID NVARCHAR(50) NOT NULL,           -- 指标ID
    F_VARIABLE_NAME NVARCHAR(100) NOT NULL,         -- 变量名称（公式中使用）
    F_SOURCE_TYPE NVARCHAR(20) NOT NULL,            -- 来源类型：COLUMN/DIMENSION/CONSTANT
    F_SOURCE_ID NVARCHAR(100),                      -- 来源ID（列名/维度ID/常量值）
    F_DATA_TYPE NVARCHAR(20) NOT NULL,              -- 数据类型
    F_IS_REQUIRED BIT NOT NULL DEFAULT 1,           -- 是否必需
    F_DEFAULT_VALUE NVARCHAR(200),                  -- 默认值
    F_SORTCODE BIGINT,                              -- 排序码
    FOREIGN KEY (F_INDICATOR_ID) REFERENCES LAB_INDICATOR_DEFINITION(F_ID),
    -- 基础字段（继承CLDEntityBase）
    F_CREATOR_TIME DATETIME,
    F_CREATOR_USER_ID NVARCHAR(50),
    F_TENANTID NVARCHAR(50)
);

CREATE INDEX IDX_VARIABLE_INDICATOR ON LAB_INDICATOR_VARIABLE(F_INDICATOR_ID, F_TENANTID);
```

### 3.3 公式版本表（LAB_INDICATOR_FORMULA_VERSION）
```sql
CREATE TABLE LAB_INDICATOR_FORMULA_VERSION (
    F_ID NVARCHAR(50) PRIMARY KEY,
    F_INDICATOR_ID NVARCHAR(50) NOT NULL,           -- 指标ID
    F_VERSION INT NOT NULL,                         -- 版本号（从1开始）
    F_VERSION_NAME NVARCHAR(100),                   -- 版本名称（v1.0, v2.0）
    F_FORMULA_EXPRESSION NVARCHAR(2000) NOT NULL,   -- 公式表达式（历史版本）
    F_CHANGE_REASON NVARCHAR(500),                  -- 变更原因
    F_IS_CURRENT BIT NOT NULL DEFAULT 0,            -- 是否为当前版本
    -- 版本特有的基础字段
    F_VERSION_CREATE_TIME DATETIME,
    F_VERSION_CREATOR_ID NVARCHAR(50),
    FOREIGN KEY (F_INDICATOR_ID) REFERENCES LAB_INDICATOR_DEFINITION(F_ID)
);

CREATE INDEX IDX_VERSION_INDICATOR ON LAB_INDICATOR_FORMULA_VERSION(F_INDICATOR_ID);
CREATE INDEX IDX_VERSION_CURRENT ON LAB_INDICATOR_FORMULA_VERSION(F_IS_CURRENT);
```

### 3.4 指标计算结果表（可选，用于缓存）
```sql
CREATE TABLE LAB_INDICATOR_RESULT (
    F_ID NVARCHAR(50) PRIMARY KEY,
    F_INTERMEDIATE_DATA_ID NVARCHAR(50) NOT NULL,   -- 中间数据ID
    F_INDICATOR_CODE NVARCHAR(100) NOT NULL,        -- 指标编码
    F_CALCULATED_VALUE NVARCHAR(200),               -- 计算结果
    F_CALCULATION_TIME DATETIME NOT NULL,           -- 计算时间
    F_FORMULA_VERSION INT NOT NULL,                 -- 使用的公式版本
    F_CALCULATION_STATUS NVARCHAR(20),              -- 计算状态：SUCCESS/ERROR
    F_ERROR_MESSAGE NVARCHAR(1000),                 -- 错误信息
    -- 索引
    FOREIGN KEY (F_INTERMEDIATE_DATA_ID) REFERENCES LAB_INTERMEDIATE_DATA(F_ID)
);

CREATE INDEX IDX_RESULT_DATA_INDICATOR ON LAB_INDICATOR_RESULT(F_INTERMEDIATE_DATA_ID, F_INDICATOR_CODE);
CREATE INDEX IDX_RESULT_TIME ON LAB_INDICATOR_RESULT(F_CALCULATION_TIME);
```

## 四、后端实体设计

### 4.1 指标定义实体（IndicatorDefinitionEntity.cs）
```csharp
// 文件位置：api/src/modularity/lab/Poxiao.Lab.Entity/Entity/Indicator/
[SugarTable("LAB_INDICATOR_DEFINITION")]
[Tenant(ClaimConst.TENANTID)]
public class IndicatorDefinitionEntity : CLDEntityBase
{
    [SugarColumn(ColumnName = "F_INDICATOR_NAME", Length = 100, IsNullable = false)]
    public string IndicatorName { get; set; }

    [SugarColumn(ColumnName = "F_INDICATOR_CODE", Length = 100, IsNullable = false)]
    public string IndicatorCode { get; set; }

    [SugarColumn(ColumnName = "F_DESCRIPTION", Length = 500, IsNullable = true)]
    public string Description { get; set; }

    [SugarColumn(ColumnName = "F_DATA_TYPE", Length = 20, IsNullable = false)]
    public string DataType { get; set; } = "DECIMAL";

    [SugarColumn(ColumnName = "F_FORMULA_EXPRESSION", Length = 2000, IsNullable = false)]
    public string FormulaExpression { get; set; }

    [SugarColumn(ColumnName = "F_FORMULA_LANGUAGE", Length = 20, IsNullable = false)]
    public string FormulaLanguage { get; set; } = "EXCEL";

    [SugarColumn(ColumnName = "F_CALCULATION_ORDER", IsNullable = false)]
    public int CalculationOrder { get; set; } = 0;

    [SugarColumn(ColumnName = "F_UNIT_ID", Length = 50, IsNullable = true)]
    public string UnitId { get; set; }

    [SugarColumn(ColumnName = "F_PRECISION", IsNullable = true)]
    public int? Precision { get; set; }

    [SugarColumn(ColumnName = "F_IS_ENABLED", IsNullable = false)]
    public bool IsEnabled { get; set; } = true;

    [SugarColumn(ColumnName = "F_IS_SYSTEM", IsNullable = false)]
    public bool IsSystem { get; set; } = false;

    [SugarColumn(ColumnName = "F_SORTCODE")]
    public long? SortCode { get; set; }
}
```

### 4.2 公式变量绑定实体（IndicatorVariableEntity.cs）
```csharp
[SugarTable("LAB_INDICATOR_VARIABLE")]
[Tenant(ClaimConst.TENANTID)]
public class IndicatorVariableEntity : CLDEntityBase
{
    [SugarColumn(ColumnName = "F_INDICATOR_ID", Length = 50, IsNullable = false)]
    public string IndicatorId { get; set; }

    [SugarColumn(ColumnName = "F_VARIABLE_NAME", Length = 100, IsNullable = false)]
    public string VariableName { get; set; }

    [SugarColumn(ColumnName = "F_SOURCE_TYPE", Length = 20, IsNullable = false)]
    public string SourceType { get; set; } // COLUMN/DIMENSION/CONSTANT

    [SugarColumn(ColumnName = "F_SOURCE_ID", Length = 100, IsNullable = true)]
    public string SourceId { get; set; }

    [SugarColumn(ColumnName = "F_DATA_TYPE", Length = 20, IsNullable = false)]
    public string DataType { get; set; }

    [SugarColumn(ColumnName = "F_IS_REQUIRED", IsNullable = false)]
    public bool IsRequired { get; set; } = true;

    [SugarColumn(ColumnName = "F_DEFAULT_VALUE", Length = 200, IsNullable = true)]
    public string DefaultValue { get; set; }

    [SugarColumn(ColumnName = "F_SORTCODE")]
    public long? SortCode { get; set; }
}
```

### 4.3 公式版本实体（IndicatorFormulaVersionEntity.cs）
```csharp
[SugarTable("LAB_INDICATOR_FORMULA_VERSION")]
[Tenant(ClaimConst.TENANTID)]
public class IndicatorFormulaVersionEntity : CLDEntityBase
{
    [SugarColumn(ColumnName = "F_INDICATOR_ID", Length = 50, IsNullable = false)]
    public string IndicatorId { get; set; }

    [SugarColumn(ColumnName = "F_VERSION", IsNullable = false)]
    public int Version { get; set; }

    [SugarColumn(ColumnName = "F_VERSION_NAME", Length = 100, IsNullable = true)]
    public string VersionName { get; set; }

    [SugarColumn(ColumnName = "F_FORMULA_EXPRESSION", Length = 2000, IsNullable = false)]
    public string FormulaExpression { get; set; }

    [SugarColumn(ColumnName = "F_CHANGE_REASON", Length = 500, IsNullable = true)]
    public string ChangeReason { get; set; }

    [SugarColumn(ColumnName = "F_IS_CURRENT", IsNullable = false)]
    public bool IsCurrent { get; set; } = false;

    [SugarColumn(ColumnName = "F_VERSION_CREATE_TIME", IsNullable = true)]
    public DateTime? VersionCreateTime { get; set; }

    [SugarColumn(ColumnName = "F_VERSION_CREATOR_ID", Length = 50, IsNullable = true)]
    public string VersionCreatorId { get; set; }
}
```

## 五、服务层设计

### 5.1 接口定义
```csharp
// IIndicatorDefinitionService.cs
namespace Poxiao.Lab.Interfaces;

public interface IIndicatorDefinitionService
{
    Task<IndicatorDefinitionDto> CreateAsync(IndicatorDefinitionInput input);
    Task<IndicatorDefinitionDto> UpdateAsync(string id, IndicatorDefinitionInput input);
    Task DeleteAsync(string id);
    Task<IndicatorDefinitionDto> GetAsync(string id);
    Task<PagedResultDto<IndicatorDefinitionDto>> GetListAsync(IndicatorDefinitionQuery input);

    // 版本管理
    Task<int> CreateVersionAsync(string indicatorId, CreateVersionInput input);
    Task<bool> SetCurrentVersionAsync(string indicatorId, int version);
    Task<List<FormulaVersionDto>> GetVersionsAsync(string indicatorId);

    // 计算相关
    Task<CalculateResultDto> CalculateAsync(CalculateInput input);
    Task<BatchCalculateResultDto> BatchCalculateAsync(BatchCalculateInput input);
}

// IFormulaEngineService.cs
public interface IFormulaEngineService
{
    Task<FormulaParseResult> ParseFormulaAsync(string formulaExpression, string formulaLanguage);
    Task<object> EvaluateAsync(FormulaContext context);
    Task ValidateFormulaAsync(string formulaExpression, List<FormulaVariable> variables);
}

// IVariableResolverService.cs
public interface IVariableResolverService
{
    Task<Dictionary<string, object>> ResolveVariablesAsync(
        List<FormulaVariable> variables,
        string intermediateDataId);
    Task<Dictionary<string, object>> ResolveVariablesFromSourceAsync(
        List<FormulaVariable> variables,
        object dataSource);
}
```

### 5.2 核心服务实现

#### 5.2.1 指标定义服务（IndicatorDefinitionService.cs）
```csharp
[ApiDescriptionSettings(Tag = "Lab", Name = "indicator-definition", Order = 210)]
[Route("api/lab/indicator-definition")]
public class IndicatorDefinitionService : IIndicatorDefinitionService, IDynamicApiController, ITransient
{
    private readonly ISqlSugarRepository<IndicatorDefinitionEntity> _repository;
    private readonly ISqlSugarRepository<IndicatorVariableEntity> _variableRepository;
    private readonly ISqlSugarRepository<IndicatorFormulaVersionEntity> _versionRepository;
    private readonly IFormulaEngineService _formulaEngine;
    private readonly IVariableResolverService _variableResolver;
    private readonly IUnitService _unitService;
    private readonly IUserManager _userManager;

    public async Task<IndicatorDefinitionDto> CreateAsync(IndicatorDefinitionInput input)
    {
        // 1. 检查指标编码唯一性
        var exists = await _repository.AnyAsync(x =>
            x.IndicatorCode == input.IndicatorCode && x.TenantId == CurrentTenantId);
        if (exists)
            throw Oops.Bah($"指标编码 {input.IndicatorCode} 已存在");

        // 2. 验证公式语法
        await ValidateFormula(input.FormulaExpression, input.Variables);

        // 3. 保存指标定义
        var entity = input.Adapt<IndicatorDefinitionEntity>();
        entity.Id = YitIdHelper.NextId().ToString();
        await _repository.InsertAsync(entity);

        // 4. 保存变量绑定
        await SaveVariables(entity.Id, input.Variables);

        // 5. 创建初始版本
        await CreateInitialVersion(entity.Id, input);

        return entity.Adapt<IndicatorDefinitionDto>();
    }

    private async Task ValidateFormula(string formula, List<FormulaVariableInput> variables)
    {
        var formulaVariables = variables.Select(v => new FormulaVariable
        {
            VariableName = v.VariableName,
            SourceType = v.SourceType,
            DataType = v.DataType
        }).ToList();

        await _formulaEngine.ValidateFormulaAsync(formula, formulaVariables);
    }
}
```

#### 5.2.2 公式引擎服务（FormulaEngineService.cs）
```csharp
public class FormulaEngineService : IFormulaEngineService
{
    private readonly ConcurrentDictionary<string, Func<IDictionary<string, object>, object>> _compiledCache;
    private readonly IVariableResolverService _variableResolver;

    public async Task<object> EvaluateAsync(FormulaContext context)
    {
        // 1. 获取编译后的函数（支持缓存）
        var compiledFunc = await GetCompiledFunctionAsync(
            context.FormulaExpression,
            context.FormulaLanguage);

        // 2. 解析变量值
        var variableValues = await _variableResolver.ResolveVariablesAsync(
            context.Variables,
            context.DataSourceId);

        // 3. 执行计算
        try
        {
            return compiledFunc(variableValues);
        }
        catch (Exception ex)
        {
            throw new FormulaExecutionException(
                $"公式执行失败: {context.FormulaExpression}", ex);
        }
    }

    private async Task<Func<IDictionary<string, object>, object>> GetCompiledFunctionAsync(
        string formula, string language)
    {
        var cacheKey = $"{language}:{formula}";

        return _compiledCache.GetOrAdd(cacheKey, key =>
        {
            return language.ToUpper() switch
            {
                "EXCEL" => CompileExcelFormula(formula),
                "MATH" => CompileMathExpression(formula),
                "SCRIPT" => CompileScript(formula),
                _ => throw new NotSupportedException($"不支持的公式语言: {language}")
            };
        });
    }

    private Func<IDictionary<string, object>, object> CompileMathExpression(string formula)
    {
        // 使用 System.Linq.Dynamic.Core 编译表达式
        var expression = DynamicExpressionParser.ParseLambda(
            typeof(IDictionary<string, object>),
            typeof(object),
            formula);

        return (variables) => expression.Compile().DynamicInvoke(variables);
    }
}
```

#### 5.2.3 变量解析服务（VariableResolverService.cs）
```csharp
public class VariableResolverService : IVariableResolverService
{
    private readonly ISqlSugarRepository<IntermediateDataEntity> _intermediateDataRepository;
    private readonly ISqlSugarRepository<PublicDimensionEntity> _dimensionRepository;
    private readonly ISqlSugarRepository<PublicDimensionVersionEntity> _dimensionVersionRepository;

    public async Task<Dictionary<string, object>> ResolveVariablesAsync(
        List<FormulaVariable> variables,
        string intermediateDataId)
    {
        var result = new Dictionary<string, object>();
        var intermediateData = await _intermediateDataRepository.GetByIdAsync(intermediateDataId);

        foreach (var variable in variables)
        {
            object value = variable.SourceType switch
            {
                "COLUMN" => GetColumnValue(intermediateData, variable.SourceId),
                "DIMENSION" => await GetDimensionValueAsync(variable.SourceId),
                "CONSTANT" => ParseConstantValue(variable.SourceId, variable.DataType),
                _ => throw new ArgumentException($"不支持的变量来源类型: {variable.SourceType}")
            };

            result[variable.VariableName] = value;
        }

        return result;
    }

    private object GetColumnValue(IntermediateDataEntity data, string columnName)
    {
        // 使用反射或表达式树获取属性值
        var property = typeof(IntermediateDataEntity).GetProperty(columnName);
        if (property == null)
            throw new ArgumentException($"中间数据表不存在列: {columnName}");

        return property.GetValue(data);
    }

    private async Task<object> GetDimensionValueAsync(string dimensionKey)
    {
        var dimension = await _dimensionRepository.GetFirstAsync(x =>
            x.DimensionKey == dimensionKey && x.TenantId == CurrentTenantId);

        if (dimension == null)
            throw new ArgumentException($"公共维度不存在: {dimensionKey}");

        // 获取当前版本的维度值
        var version = await _dimensionVersionRepository.GetFirstAsync(x =>
            x.DimensionId == dimension.Id && x.IsCurrent == 1);

        return ParseDimensionValue(dimension.ValueType, dimension.AttributeValue);
    }
}
```

### 5.3 集成中间数据服务
```csharp
// 扩展 IntermediateDataService
public class ExtendedIntermediateDataService : IntermediateDataService
{
    private readonly IIndicatorDefinitionService _indicatorService;
    private readonly IIndicatorCalculationService _calculationService;

    public async Task<IntermediateDataEntity> GenerateWithIndicators(RawDataEntity rawData)
    {
        // 1. 调用原有逻辑生成基础中间数据
        var intermediateData = await base.GenerateIntermediateData(rawData);

        // 2. 获取所有启用的指标
        var indicators = await _indicatorService.GetEnabledIndicatorsAsync();

        // 3. 按计算顺序执行指标计算
        foreach (var indicator in indicators.OrderBy(i => i.CalculationOrder))
        {
            try
            {
                var value = await _calculationService.CalculateIndicatorAsync(
                    indicator, intermediateData);

                SetIndicatorValue(intermediateData, indicator.IndicatorCode, value);
            }
            catch (Exception ex)
            {
                LogIndicatorCalculationError(indicator, intermediateData, ex);
            }
        }

        return intermediateData;
    }

    private void SetIndicatorValue(IntermediateDataEntity data, string indicatorCode, object value)
    {
        // 动态设置指标值到中间数据实体
        // 方案A：使用扩展属性（JSON字段）
        // 方案B：动态添加属性到实体
        // 方案C：存储到独立的结果表

        // 推荐方案A：使用JSON扩展字段
        var indicatorValues = JsonConvert.DeserializeObject<Dictionary<string, object>>(
            data.IndicatorValues ?? "{}");

        indicatorValues[indicatorCode] = value;
        data.IndicatorValues = JsonConvert.SerializeObject(indicatorValues);
    }
}
```

## 六、API设计

### 6.1 RESTful API端点

#### 6.1.1 指标定义管理
| 方法 | 路径 | 描述 |
|------|------|------|
| GET | `/api/lab/indicator-definition` | 获取指标定义列表（分页） |
| GET | `/api/lab/indicator-definition/{id}` | 获取指标定义详情 |
| POST | `/api/lab/indicator-definition` | 创建指标定义 |
| PUT | `/api/lab/indicator-definition/{id}` | 更新指标定义 |
| DELETE | `/api/lab/indicator-definition/{id}` | 删除指标定义 |

#### 6.1.2 公式版本管理
| 方法 | 路径 | 描述 |
|------|------|------|
| GET | `/api/lab/indicator-definition/{id}/versions` | 获取公式版本列表 |
| POST | `/api/lab/indicator-definition/{id}/versions` | 创建新版本 |
| PUT | `/api/lab/indicator-definition/{id}/versions/current` | 设置当前版本 |

#### 6.1.3 计算执行
| 方法 | 路径 | 描述 |
|------|------|------|
| POST | `/api/lab/indicator-calculation/single` | 单条数据计算 |
| POST | `/api/lab/indicator-calculation/batch` | 批量数据计算 |
| POST | `/api/lab/indicator-calculation/rebuild` | 重建历史数据 |

### 6.2 DTO设计

#### 6.2.1 输入DTO
```csharp
// IndicatorDefinitionInput.cs
public class IndicatorDefinitionInput
{
    [Required(ErrorMessage = "指标名称不能为空")]
    [StringLength(100, ErrorMessage = "指标名称长度不能超过100个字符")]
    public string IndicatorName { get; set; }

    [Required(ErrorMessage = "指标编码不能为空")]
    [StringLength(100, ErrorMessage = "指标编码长度不能超过100个字符")]
    [RegularExpression("^[A-Z][A-Z0-9_]*$", ErrorMessage = "指标编码必须为大写字母、数字和下划线")]
    public string IndicatorCode { get; set; }

    public string Description { get; set; }

    [Required(ErrorMessage = "公式表达式不能为空")]
    public string FormulaExpression { get; set; }

    public string FormulaLanguage { get; set; } = "EXCEL";

    public int CalculationOrder { get; set; }

    public string UnitId { get; set; }

    public int? Precision { get; set; }

    public bool IsEnabled { get; set; } = true;

    public List<FormulaVariableInput> Variables { get; set; }
}

public class FormulaVariableInput
{
    [Required]
    public string VariableName { get; set; }

    [Required]
    public string SourceType { get; set; } // COLUMN/DIMENSION/CONSTANT

    public string SourceId { get; set; }

    [Required]
    public string DataType { get; set; }

    public bool IsRequired { get; set; } = true;

    public string DefaultValue { get; set; }
}
```

#### 6.2.2 查询DTO
```csharp
// IndicatorDefinitionQuery.cs
public class IndicatorDefinitionQuery : PageInputBase
{
    public string Keyword { get; set; }

    public bool? IsEnabled { get; set; }

    public bool? IsSystem { get; set; }

    public string DataType { get; set; }

    public string OrderBy { get; set; } = "CalculationOrder";
}
```

#### 6.2.3 输出DTO
```csharp
// IndicatorDefinitionDto.cs
public class IndicatorDefinitionDto : CLDEntityBase
{
    public string IndicatorName { get; set; }

    public string IndicatorCode { get; set; }

    public string Description { get; set; }

    public string DataType { get; set; }

    public string FormulaExpression { get; set; }

    public string FormulaLanguage { get; set; }

    public int CalculationOrder { get; set; }

    public string UnitId { get; set; }

    public string UnitName { get; set; }  // 扩展字段

    public int? Precision { get; set; }

    public bool IsEnabled { get; set; }

    public bool IsSystem { get; set; }

    public long? SortCode { get; set; }

    public List<FormulaVariableDto> Variables { get; set; }

    public int CurrentVersion { get; set; }
}
```

## 七、前端设计

### 7.1 目录结构
```
web/src/views/lab/indicator/
├── index.vue                  # 指标列表页面
├── Form.vue                   # 指标表单（创建/编辑）
├── components/
│   ├── FormulaEditor.vue      # 公式编辑器组件
│   ├── VariableBinding.vue    # 变量绑定组件
│   ├── VersionHistory.vue     # 版本历史组件
│   └── CalculationPreview.vue # 计算预览组件
└── calculation/
    ├── index.vue              # 计算执行页面
    └── ResultView.vue         # 计算结果查看
```

### 7.2 API客户端
```typescript
// web/src/api/lab/indicator.ts
import { request } from '@/utils/request';
import type {
  IndicatorDefinitionDto,
  IndicatorDefinitionInput,
  IndicatorDefinitionQuery,
  CalculateInput,
  CalculateResultDto
} from './types/indicator';

export enum Api {
  Prefix = '/api/lab/indicator-definition',
  Calculation = '/api/lab/indicator-calculation'
}

// 指标定义管理
export function getIndicatorList(params: IndicatorDefinitionQuery) {
  return request.get<PageResult<IndicatorDefinitionDto>>({
    url: Api.Prefix,
    params
  });
}

export function getIndicatorDetail(id: string) {
  return request.get<IndicatorDefinitionDto>({
    url: `${Api.Prefix}/${id}`
  });
}

export function createIndicator(data: IndicatorDefinitionInput) {
  return request.post<IndicatorDefinitionDto>({
    url: Api.Prefix,
    data
  });
}

export function updateIndicator(id: string, data: IndicatorDefinitionInput) {
  return request.put<IndicatorDefinitionDto>({
    url: `${Api.Prefix}/${id}`,
    data
  });
}

// 公式计算
export function calculateSingle(data: CalculateInput) {
  return request.post<CalculateResultDto>({
    url: `${Api.Calculation}/single`,
    data
  });
}

export function calculateBatch(data: BatchCalculateInput) {
  return request.post<BatchCalculateResultDto>({
    url: `${Api.Calculation}/batch`,
    data
  });
}
```

### 7.3 公式编辑器组件
```vue
<!-- FormulaEditor.vue -->
<template>
  <div class="formula-editor">
    <div class="editor-header">
      <a-select v-model:value="formulaLanguage" style="width: 120px">
        <a-select-option value="EXCEL">Excel公式</a-select-option>
        <a-select-option value="MATH">数学表达式</a-select-option>
      </a-select>

      <div class="variable-palette">
        <a-space>
          <a-tag v-for="var in availableVariables"
                 :key="var.name"
                 @click="insertVariable(var.name)"
                 class="variable-tag">
            {{ var.name }}
          </a-tag>
        </a-space>
      </div>
    </div>

    <div class="editor-body">
      <a-textarea
        v-model:value="formulaExpression"
        :rows="4"
        placeholder="请输入公式表达式，如：F_FOUR_METER_WT / STD_LENGTH"
        @change="handleFormulaChange"
      />

      <div v-if="validationError" class="error-message">
        <a-alert type="error" :message="validationError" show-icon />
      </div>
    </div>

    <div class="editor-footer">
      <a-button @click="validateFormula">验证公式</a-button>
      <a-button type="primary" @click="testFormula">测试计算</a-button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { message } from 'ant-design-vue';

const props = defineProps<{
  modelValue: string;
  variables: FormulaVariable[];
}>();

const emit = defineEmits<{
  'update:modelValue': [value: string];
  'validate': [isValid: boolean];
}>();

const formulaExpression = ref(props.modelValue);
const formulaLanguage = ref('EXCEL');
const validationError = ref('');

const availableVariables = computed(() => {
  return props.variables.map(v => ({
    name: v.variableName,
    type: v.sourceType,
    description: `${v.variableName} (${v.sourceType}:${v.sourceId})`
  }));
});

const insertVariable = (varName: string) => {
  const textarea = document.querySelector('.formula-editor textarea');
  if (textarea) {
    const start = (textarea as HTMLTextAreaElement).selectionStart;
    const end = (textarea as HTMLTextAreaElement).selectionEnd;
    const newValue = formulaExpression.value.substring(0, start) +
                    varName +
                    formulaExpression.value.substring(end);
    formulaExpression.value = newValue;
    emit('update:modelValue', newValue);
  }
};

const validateFormula = async () => {
  try {
    await validateFormulaApi({
      expression: formulaExpression.value,
      language: formulaLanguage.value,
      variables: props.variables
    });
    validationError.value = '';
    message.success('公式验证通过');
    emit('validate', true);
  } catch (error: any) {
    validationError.value = error.message;
    emit('validate', false);
  }
};
</script>
```

## 八、实施路线图

### 8.1 阶段一：基础框架（2-3周）
**目标**：建立指标定义管理和简单公式计算
- [ ] 数据库表设计和迁移脚本
- [ ] 实体类和DTO定义
- [ ] 指标定义CRUD服务
- [ ] 基础公式解析引擎（四则运算）
- [ ] 单元测试框架

**交付物**：
- 指标定义管理界面
- 基础公式编辑和验证
- 单条数据计算API

### 8.2 阶段二：增强功能（3-4周）
**目标**：完善变量绑定和版本管理
- [ ] 变量绑定系统（列、维度、常量）
- [ ] 公式版本管理
- [ ] 公共维度集成
- [ ] 批量计算功能
- [ ] 计算结果缓存

**交付物**：
- 完整的变量绑定界面
- 公式版本历史管理
- 批量计算和进度跟踪

### 8.3 阶段三：高级特性（2-3周）
**目标**：性能优化和高级功能
- [ ] 公式编译和缓存优化
- [ ] 依赖分析和计算顺序优化
- [ ] 公式调试工具
- [ ] 性能监控和日志
- [ ] 与中间数据生成的集成

**交付物**：
- 高性能计算引擎
- 公式调试和测试工具
- 完整的监控和日志

### 8.4 阶段四：迁移和优化（1-2周）
**目标**：迁移现有计算逻辑
- [ ] 现有硬编码公式迁移到指标定义
- [ ] 历史数据重新计算
- [ ] 性能测试和优化
- [ ] 文档和培训

**交付物**：
- 完整的指标库
- 性能测试报告
- 用户操作手册

## 九、技术选型

### 9.1 核心依赖
| 组件 | 选择 | 理由 |
|------|------|------|
| 表达式引擎 | System.Linq.Dynamic.Core | 轻量级，性能好，支持动态表达式 |
| JSON处理 | Newtonsoft.Json | 项目现有依赖，成熟稳定 |
| 对象映射 | Mapster | 性能优于AutoMapper |
| 缓存 | MemoryCache + Redis | 内存缓存热数据，Redis分布式缓存 |

### 9.2 公式语言支持
1. **Excel风格公式**（优先级最高）
   - 支持Excel常用函数：SUM、AVERAGE、MAX、MIN
   - 支持单元格引用：A1、B2等（转换为列名）
   - 语法示例：`F_FOUR_METER_WT / STD_LENGTH`

2. **数学表达式**
   - 支持四则运算：`+ - * /`
   - 支持函数：`sqrt()、pow()、log()`
   - 支持括号：`(a + b) * c`

3. **脚本语言**（可选）
   - C#脚本：使用Roslyn编译
   - 限制：仅允许白名单函数和类型

### 9.3 安全策略
1. **表达式沙箱**：限制可访问的类型和函数
2. **资源限制**：限制执行时间和内存使用
3. **输入验证**：严格验证公式语法和变量
4. **审计日志**：记录所有公式修改和计算操作

## 十、测试策略

### 10.1 单元测试
```csharp
// FormulaEngineTests.cs
[TestClass]
public class FormulaEngineTests
{
    [TestMethod]
    public async Task Should_CalculateExcelFormula_Correctly()
    {
        // Arrange
        var formula = "F_FOUR_METER_WT / STD_LENGTH";
        var variables = new Dictionary<string, object>
        {
            ["F_FOUR_METER_WT"] = 4000m,
            ["STD_LENGTH"] = 4m
        };

        // Act
        var result = await _formulaEngine.EvaluateAsync(formula, "EXCEL", variables);

        // Assert
        Assert.AreEqual(1000m, result);
    }

    [TestMethod]
    public async Task Should_ThrowException_WhenVariableMissing()
    {
        // Arrange
        var formula = "A + B";
        var variables = new Dictionary<string, object>
        {
            ["A"] = 10m
        };

        // Act & Assert
        await Assert.ThrowsExceptionAsync<VariableNotFoundException>(() =>
            _formulaEngine.EvaluateAsync(formula, "EXCEL", variables));
    }
}
```

### 10.2 集成测试
```csharp
[TestClass]
public class IndicatorIntegrationTests : IntegrationTestBase
{
    [TestMethod]
    public async Task Should_CreateIndicator_And_Calculate()
    {
        // 1. 创建指标定义
        var input = new IndicatorDefinitionInput
        {
            IndicatorName = "一米带材重量",
            IndicatorCode = "ONE_METER_WT",
            FormulaExpression = "F_FOUR_METER_WT / STD_LENGTH",
            Variables = new List<FormulaVariableInput>
            {
                new() { VariableName = "F_FOUR_METER_WT", SourceType = "COLUMN", SourceId = "F_FOUR_METER_WT" },
                new() { VariableName = "STD_LENGTH", SourceType = "DIMENSION", SourceId = "length" }
            }
        };

        var indicator = await _indicatorService.CreateAsync(input);

        // 2. 创建中间数据
        var intermediateData = new IntermediateDataEntity
        {
            F_FOUR_METER_WT = 4000m
        };

        // 3. 计算指标
        var result = await _calculationService.CalculateAsync(new CalculateInput
        {
            IndicatorId = indicator.Id,
            IntermediateDataId = intermediateData.Id
        });

        // 4. 验证结果
        Assert.IsTrue(result.Success);
        Assert.AreEqual(1000m, result.Value);
    }
}
```

### 10.3 性能测试
1. **单公式计算性能**：目标 < 10ms
2. **批量计算性能**：1000条数据 < 1秒
3. **并发计算性能**：支持100并发计算
4. **内存使用**：公式编译缓存 < 100MB

## 十一、部署和维护

### 11.1 数据库迁移
```sql
-- 创建指标相关表
-- 文件位置：sql/migration_create_indicator_tables.sql
-- 需要包含：LAB_INDICATOR_DEFINITION, LAB_INDICATOR_VARIABLE, LAB_INDICATOR_FORMULA_VERSION

-- 迁移现有硬编码公式
INSERT INTO LAB_INDICATOR_DEFINITION (F_ID, F_INDICATOR_NAME, F_INDICATOR_CODE, ...)
VALUES
('IND001', '一米带材重量', 'ONE_METER_WT', 'F_FOUR_METER_WT / STD_LENGTH', ...),
('IND002', '平均厚度', 'AVG_THICKNESS', 'AVG(F_THICK_1..F_THICK_22)', ...);
```

### 11.2 监控指标
1. **业务指标**
   - 指标定义总数
   - 公式计算成功率
   - 平均计算耗时

2. **系统指标**
   - 公式编译缓存命中率
   - 内存使用情况
   - 数据库查询性能

### 11.3 维护任务
1. **定期清理**：清理过期的计算结果缓存
2. **性能优化**：监控慢查询和优化索引
3. **安全更新**：定期更新表达式引擎安全配置
4. **备份策略**：指标定义和公式版本需要定期备份

## 十二、常见问题处理

### 12.1 公式计算失败
**问题**：公式执行时抛出异常
**解决**：
1. 检查变量值是否存在
2. 验证公式语法是否正确
3. 检查数据类型是否匹配
4. 查看详细错误日志

### 12.2 性能问题
**问题**：批量计算速度慢
**解决**：
1. 启用公式编译缓存
2. 优化数据库查询
3. 使用并行计算
4. 增加服务器资源

### 12.3 数据一致性问题
**问题**：历史数据计算结果不一致
**解决**：
1. 使用公式版本号标记计算历史
2. 提供重新计算功能
3. 记录计算使用的公式版本

## 附录

### A. 现有硬编码公式迁移清单
| 公式 | 位置 | 目标指标编码 | 公式表达式 |
|------|------|--------------|------------|
| 一米带材重量 | IntermediateDataEntity:180 | ONE_METER_WT | F_FOUR_METER_WT / STD_LENGTH |
| 平均厚度 | IntermediateDataEntity:372 | AVG_THICKNESS | AVG(F_THICK_1..F_THICK_22) |
| 密度 | IntermediateDataEntity:378 | DENSITY | (F_ONE_METER_WT * 1000) / (F_WIDTH * F_AVG_THICK) |
| 叠片系数 | IntermediateDataEntity:384 | LAMINATION_FACTOR | F_FOUR_METER_WT / (F_WIDTH * 400 * F_AVG_THICK * THEO_DENSITY * 10^-7) |

### B. 关键文件路径
| 文件 | 路径 |
|------|------|
| 指标定义实体 | `api/src/modularity/lab/Poxiao.Lab.Entity/Entity/Indicator/` |
| 指标服务接口 | `api/src/modularity/lab/Poxiao.Lab.Interfaces/` |
| 指标服务实现 | `api/src/modularity/lab/Poxiao.Lab/Service/Indicator/` |
| 控制器 | `api/src/modularity/lab/Poxiao.Lab/Controllers/` |
| 前端页面 | `web/src/views/lab/indicator/` |
| 前端API | `web/src/api/lab/indicator.ts` |
| 数据库脚本 | `sql/migration_create_indicator_tables.sql` |

### C. 开发环境配置
```bash
# 1. 创建数据库表
sqlcmd -S localhost -d LabDB -i sql/migration_create_indicator_tables.sql

# 2. 启动后端服务
cd api/src/application/Poxiao.API.Entry
dotnet watch run --launch-profile dev

# 3. 启动前端服务
cd web
pnpm install
pnpm dev
```

---

**文档版本**：v1.0
**最后更新**：2026-01-20
**维护团队**：实验室数据系统开发组