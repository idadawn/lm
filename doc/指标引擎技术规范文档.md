# 指标引擎技术规范文档

## ⚠️ 重要说明：Indicator 和 Metric 整合

**更新日期**：2026-01-27

Indicator 和 Metric 系统已整合，统一使用 **Metric** 系统。所有代码、API、数据库表均使用 Metric 命名。

- ✅ 统一使用 `MetricDefinitionEntity`（表：`lab_metric_definition`）
- ✅ 统一使用 `MetricDefinitionService`（API：`/api/lab/metric-definitions`）
- ✅ 前端统一使用 Metric 页面和 API
- ✅ 数据迁移脚本：`sql/migration_merge_indicator_to_metric.sql`

**注意**：本文档中如有提到 Indicator，均指 Metric 系统。

## 1. 项目概述

### 1.1 项目目标
在Lab模块下实现可配置的指标计算引擎，支持：
- 动态定义指标和计算公式
- 支持变量绑定和数据源集成
- 提供高性能的计算服务
- 支持版本管理和批量计算

### 1.2 技术栈
- **后端框架**: .NET 10.0 (ASP.NET Core)
- **表达式引擎**: System.Linq.Dynamic.Core
- **ORM**: SqlSugar
- **前端框架**: Vue 3 + TypeScript
- **UI组件库**: Ant Design Vue 3
- **测试框架**: xUnit (后端) + Vitest (前端)

### 1.3 架构原则
1. **模块化设计**: 遵循现有模块化架构
2. **关注点分离**: 实体、DTO、服务、接口清晰分离
3. **可扩展性**: 支持未来功能扩展
4. **性能优先**: 优化计算性能，支持缓存
5. **向后兼容**: 不影响现有功能

## 2. 数据库设计

### 2.1 核心表结构

#### 2.1.1 指标定义表 (lab_metric_definition)
```sql
CREATE TABLE lab_metric_definition (
    id VARCHAR(50) PRIMARY KEY COMMENT '主键ID',
    name VARCHAR(100) NOT NULL COMMENT '指标名称',
    code VARCHAR(50) NOT NULL UNIQUE COMMENT '指标代码（唯一）',
    description VARCHAR(500) COMMENT '指标描述',
    formula TEXT NOT NULL COMMENT '计算公式',
    unit_id VARCHAR(50) COMMENT '单位ID，关联unit_definition表',
    category VARCHAR(100) COMMENT '指标分类',
    status TINYINT DEFAULT 1 COMMENT '状态：1-启用，0-禁用',
    sort_order INT DEFAULT 0 COMMENT '排序序号',
    remark VARCHAR(1000) COMMENT '备注',
    creator_user_id VARCHAR(50) COMMENT '创建者ID',
    creator_time DATETIME COMMENT '创建时间',
    last_modify_user_id VARCHAR(50) COMMENT '最后修改者ID',
    last_modify_time DATETIME COMMENT '最后修改时间',
    tenant_id VARCHAR(50) COMMENT '租户ID',
    INDEX idx_code (code),
    INDEX idx_category (category),
    INDEX idx_status (status),
    INDEX idx_creator_time (creator_time)
) COMMENT='指标定义表';
```

#### 2.1.2 指标计算结果表 (lab_metric_result) - 阶段二
```sql
CREATE TABLE lab_metric_result (
    id VARCHAR(50) PRIMARY KEY COMMENT '主键ID',
    metric_definition_id VARCHAR(50) NOT NULL COMMENT '指标定义ID',
    raw_data_id VARCHAR(50) COMMENT '原始数据ID',
    intermediate_data_id VARCHAR(50) COMMENT '中间数据ID',
    result_value DECIMAL(20, 6) COMMENT '计算结果值',
    result_string VARCHAR(100) COMMENT '结果字符串表示',
    unit_id VARCHAR(50) COMMENT '单位ID',
    variable_values JSON COMMENT '变量值快照（JSON格式）',
    calculation_time DATETIME COMMENT '计算时间',
    elapsed_milliseconds BIGINT COMMENT '计算耗时（毫秒）',
    success TINYINT DEFAULT 1 COMMENT '是否成功：1-成功，0-失败',
    error_message TEXT COMMENT '错误信息',
    creator_time DATETIME COMMENT '创建时间',
    INDEX idx_metric_definition (metric_definition_id),
    INDEX idx_raw_data (raw_data_id),
    INDEX idx_intermediate_data (intermediate_data_id),
    INDEX idx_calculation_time (calculation_time)
) COMMENT='指标计算结果表';
```

### 2.2 数据库迁移脚本位置
所有迁移脚本应放置在：`api/sql/migration_*.sql`

## 3. 后端架构

### 3.1 目录结构
```
Poxiao.Lab.Entity/
├── Entity/
│   ├── MetricDefinitionEntity.cs
│   └── MetricResultEntity.cs
├── Dto/
│   └── Metric/
│       ├── MetricDefinitionInput.cs
│       ├── MetricDefinitionQuery.cs
│       ├── MetricDefinitionDto.cs
│       ├── MetricCalculationInput.cs
│       ├── MetricCalculationResult.cs
│       ├── FormulaValidationInput.cs
│       └── FormulaValidationResult.cs
└── Config/
    └── MetricEngineConfig.cs

Poxiao.Lab.Interfaces/
├── IMetricDefinitionService.cs
├── IMetricCalculationService.cs
└── IMetricResultService.cs

Poxiao.Lab/
├── Service/
│   ├── MetricDefinitionService.cs
│   ├── MetricCalculationService.cs
│   └── MetricResultService.cs
├── Helpers/
│   └── FormulaParser.cs
└── Extensions/
    └── MetricExtensions.cs
```

### 3.2 核心实体类

#### 3.2.1 MetricDefinitionEntity
```csharp
[SugarTable("lab_metric_definition")]
public class MetricDefinitionEntity : CLDEntityBase
{
    [SugarColumn(ColumnName = "name", Length = 100)]
    public string Name { get; set; }

    [SugarColumn(ColumnName = "code", Length = 50, IsNullable = false)]
    public string Code { get; set; }

    [SugarColumn(ColumnName = "description", Length = 500)]
    public string Description { get; set; }

    [SugarColumn(ColumnName = "formula", ColumnDataType = "TEXT")]
    public string Formula { get; set; }

    [SugarColumn(ColumnName = "unit_id", Length = 50)]
    public string UnitId { get; set; }

    [SugarColumn(ColumnName = "category", Length = 100)]
    public string Category { get; set; }

    [SugarColumn(ColumnName = "status")]
    public int Status { get; set; } = 1;

    [SugarColumn(ColumnName = "sort_order")]
    public int SortOrder { get; set; }

    [SugarColumn(ColumnName = "remark", Length = 1000)]
    public string Remark { get; set; }

    [SugarColumn(IsIgnore = true)]
    public string UnitName { get; set; }
}
```

### 3.3 服务接口设计

#### 3.3.1 IMetricDefinitionService
```csharp
public interface IMetricDefinitionService : ITransient
{
    Task<List<MetricDefinitionDto>> GetList(MetricDefinitionQuery input);
    Task<MetricDefinitionDto> GetInfo(string id);
    Task<MetricDefinitionDto> Create(MetricDefinitionInput input);
    Task<MetricDefinitionDto> Update(string id, MetricDefinitionInput input);
    Task Delete(string id);
    Task<MetricDefinitionDto> UpdateStatus(string id, int status);
    Task<List<string>> GetCategories();
}
```

#### 3.3.2 IMetricCalculationService
```csharp
public interface IMetricCalculationService : ITransient
{
    Task<MetricCalculationResult> Calculate(MetricCalculationInput input);
    Task<FormulaValidationResult> ValidateFormula(FormulaValidationInput input);
    Task<List<MetricCalculationResult>> BatchCalculate(List<MetricCalculationInput> inputs);
}
```

### 3.4 公式引擎实现

#### 3.4.1 核心计算逻辑
```csharp
public class FormulaParser
{
    private readonly IUnitConversionService _unitConversionService;

    public FormulaParser(IUnitConversionService unitConversionService)
    {
        _unitConversionService = unitConversionService;
    }

    public decimal? Calculate(string formula, Dictionary<string, object> variables)
    {
        try
        {
            // 1. 替换变量占位符
            string expression = ReplaceVariables(formula, variables);

            // 2. 验证表达式语法
            if (!ValidateExpression(expression))
                throw new FormulaException("表达式语法错误");

            // 3. 使用System.Linq.Dynamic.Core计算
            var parameter = new { };
            var result = System.Linq.Dynamic.Core.DynamicExpressionParser
                .ParseLambda(new[] { parameter }, typeof(decimal?), expression)
                .Compile()
                .DynamicInvoke(parameter);

            return (decimal?)result;
        }
        catch (Exception ex)
        {
            throw new FormulaException($"计算失败: {ex.Message}", ex);
        }
    }

    private string ReplaceVariables(string formula, Dictionary<string, object> variables)
    {
        // 将变量名替换为实际值
        foreach (var variable in variables)
        {
            string pattern = $@"\b{variable.Key}\b";
            formula = Regex.Replace(formula, pattern, variable.Value.ToString());
        }
        return formula;
    }
}
```

#### 3.4.2 支持的运算符和函数
- 算术运算符: `+`, `-`, `*`, `/`, `%`, `^`
- 比较运算符: `==`, `!=`, `>`, `<`, `>=`, `<=`
- 逻辑运算符: `&&`, `||`, `!`
- 数学函数: `sqrt`, `abs`, `round`, `floor`, `ceil`, `max`, `min`
- 统计函数: `avg`, `sum`, `count` (阶段二)

### 3.5 API控制器实现

#### 3.5.1 MetricDefinitionService (作为控制器)
```csharp
[ApiDescriptionSettings("Lab", Tag = "指标定义管理")]
[Route("api/lab/metric-definitions")]
[DynamicApiController]
public class MetricDefinitionService : IMetricDefinitionService
{
    private readonly ISqlSugarRepository<MetricDefinitionEntity> _repository;
    private readonly IUserManager _userManager;

    public MetricDefinitionService(
        ISqlSugarRepository<MetricDefinitionEntity> repository,
        IUserManager userManager)
    {
        _repository = repository;
        _userManager = userManager;
    }

    [HttpGet("")]
    public async Task<List<MetricDefinitionDto>> GetList([FromQuery] MetricDefinitionQuery input)
    {
        // 实现分页查询逻辑
    }

    [HttpGet("{id}")]
    public async Task<MetricDefinitionDto> GetInfo(string id)
    {
        // 实现详情查询逻辑
    }

    [HttpPost("")]
    public async Task<MetricDefinitionDto> Create([FromBody] MetricDefinitionInput input)
    {
        // 实现创建逻辑，包含重复性检查
    }

    [HttpPut("{id}")]
    public async Task<MetricDefinitionDto> Update(string id, [FromBody] MetricDefinitionInput input)
    {
        // 实现更新逻辑
    }

    [HttpDelete("{id}")]
    public async Task Delete(string id)
    {
        // 实现删除逻辑
    }
}
```

## 4. 前端架构

### 4.1 目录结构
```
web/src/
├── views/lab/metric/
│   ├── index.vue              # 指标列表页面
│   ├── Form.vue              # 指标表单页面
│   ├── components/
│   │   ├── MetricTable.vue   # 指标表格组件
│   │   ├── FormulaEditor.vue # 公式编辑器组件
│   │   └── Calculator.vue    # 计算器组件
│   └── types/
│       └── metric.ts         # TypeScript类型定义
├── api/lab/
│   └── metric.ts             # 指标相关API调用
└── store/modules/
    └── metric.ts             # Pinia状态管理
```

### 4.2 TypeScript类型定义
```typescript
// metric.ts
export interface MetricDefinition {
  id: string;
  name: string;
  code: string;
  description: string;
  formula: string;
  unitId: string;
  unitName: string;
  category: string;
  status: number;
  sortOrder: number;
  creatorTime: string;
  creatorUserName: string;
}

export interface MetricDefinitionQuery extends PageQuery {
  category?: string;
  status?: number;
  creatorTimeStart?: string;
  creatorTimeEnd?: string;
}

export interface MetricCalculationInput {
  metricDefinitionId?: string;
  metricCode?: string;
  contextData: Record<string, any>;
  rawDataId?: string;
  intermediateDataId?: string;
}
```

### 4.3 API客户端
```typescript
// metric.ts
import { request } from '@/utils/request';

export function getMetricDefinitionList(params: MetricDefinitionQuery) {
  return request.get<PaginatedResponse<MetricDefinition>>(
    '/api/lab/metric-definitions',
    { params }
  );
}

export function createMetricDefinition(data: MetricDefinitionInput) {
  return request.post<MetricDefinition>('/api/lab/metric-definitions', data);
}

export function calculateMetric(data: MetricCalculationInput) {
  return request.post<MetricCalculationResult>('/api/lab/metrics/calculate', data);
}

export function validateFormula(data: FormulaValidationInput) {
  return request.post<FormulaValidationResult>('/api/lab/metrics/validate-formula', data);
}
```

### 4.4 公式编辑器组件
```vue
<!-- FormulaEditor.vue -->
<template>
  <div class="formula-editor">
    <a-input
      v-model:value="formula"
      placeholder="输入计算公式，如：(width * thickness * density) / 1000"
      @change="handleFormulaChange"
    />
    <div class="variables-panel">
      <h4>可用变量</h4>
      <a-tag
        v-for="variable in availableVariables"
        :key="variable.name"
        @click="insertVariable(variable.name)"
        class="variable-tag"
      >
        {{ variable.name }} ({{ variable.type }})
      </a-tag>
    </div>
    <div v-if="validationResult" class="validation-result">
      <a-alert
        :type="validationResult.isValid ? 'success' : 'error'"
        :message="validationResult.isValid ? '公式有效' : '公式无效'"
      />
      <div v-if="validationResult.undefinedVariables.length">
        未定义变量: {{ validationResult.undefinedVariables.join(', ') }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import { validateFormula } from '@/api/lab/metric';

interface Variable {
  name: string;
  type: string;
}

const props = defineProps<{
  modelValue: string;
  availableVariables: Variable[];
}>();

const emit = defineEmits<{
  'update:modelValue': [value: string];
  'validation': [result: FormulaValidationResult];
}>();

const formula = ref(props.modelValue);
const validationResult = ref<FormulaValidationResult>();

const handleFormulaChange = async () => {
  emit('update:modelValue', formula.value);

  // 实时验证公式
  if (formula.value.trim()) {
    const result = await validateFormula({
      formula: formula.value,
      availableVariables: props.availableVariables.reduce((acc, v) => {
        acc[v.name] = v.type;
        return acc;
      }, {} as Record<string, string>)
    });
    validationResult.value = result;
    emit('validation', result);
  }
};

const insertVariable = (variableName: string) => {
  const input = document.querySelector('.formula-editor input');
  if (input) {
    const start = (input as HTMLInputElement).selectionStart || 0;
    const end = (input as HTMLInputElement).selectionEnd || 0;
    formula.value =
      formula.value.substring(0, start) +
      variableName +
      formula.value.substring(end);
    emit('update:modelValue', formula.value);
    handleFormulaChange();
  }
};
</script>
```

## 5. 单元测试规范

### 5.1 后端测试
```csharp
[Fact]
public async Task Calculate_ValidFormula_ReturnsCorrectResult()
{
    // Arrange
    var formula = "(width * height) / 2";
    var variables = new Dictionary<string, object>
    {
        { "width", 10 },
        { "height", 5 }
    };

    // Act
    var result = await _formulaParser.Calculate(formula, variables);

    // Assert
    Assert.Equal(25, result);
}

[Fact]
public async Task ValidateFormula_InvalidSyntax_ReturnsError()
{
    // Arrange
    var input = new FormulaValidationInput
    {
        Formula = "width * + height", // 无效语法
        AvailableVariables = new Dictionary<string, string>
        {
            { "width", "number" },
            { "height", "number" }
        }
    };

    // Act
    var result = await _metricCalculationService.ValidateFormula(input);

    // Assert
    Assert.False(result.IsValid);
    Assert.NotNull(result.SyntaxError);
}
```

### 5.2 前端测试
```typescript
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import FormulaEditor from './FormulaEditor.vue';

describe('FormulaEditor', () => {
  it('should emit validation result when formula changes', async () => {
    const wrapper = mount(FormulaEditor, {
      props: {
        modelValue: '',
        availableVariables: [
          { name: 'width', type: 'number' }
        ]
      }
    });

    const input = wrapper.find('input');
    await input.setValue('width * 2');

    // 验证事件触发
    expect(wrapper.emitted('update:modelValue')).toBeTruthy();
  });
});
```

## 6. 集成指南

### 6.1 与现有服务集成

#### 6.1.1 与IntermediateDataService集成
```csharp
public class IntermediateDataService
{
    private readonly IMetricCalculationService _metricCalculationService;

    public async Task<IntermediateDataEntity> GenerateIntermediateData(
        RawDataEntity rawData,
        List<string> metricDefinitionIds)
    {
        // 生成中间数据...

        // 计算指标
        foreach (var metricId in metricDefinitionIds)
        {
            var calculationInput = new MetricCalculationInput
            {
                MetricDefinitionId = metricId,
                ContextData = BuildContextData(rawData),
                RawDataId = rawData.Id
            };

            var result = await _metricCalculationService.Calculate(calculationInput);

            // 存储计算结果到中间数据
            intermediateData.MetricResults.Add(result);
        }

        return intermediateData;
    }
}
```

#### 6.1.2 与UnitConversionService集成
```csharp
public class MetricCalculationService
{
    private readonly IUnitConversionService _unitConversionService;

    private async Task<decimal?> CalculateWithUnitConversion(
        string formula,
        Dictionary<string, object> variables,
        string targetUnitId)
    {
        // 计算原始结果
        var rawResult = _formulaParser.Calculate(formula, variables);

        // 单位转换
        if (!string.IsNullOrEmpty(targetUnitId) && rawResult.HasValue)
        {
            // 获取公式中的单位信息
            var sourceUnitId = DetectSourceUnit(formula, variables);
            if (!string.IsNullOrEmpty(sourceUnitId))
            {
                return await _unitConversionService.Convert(
                    rawResult.Value,
                    sourceUnitId,
                    targetUnitId
                );
            }
        }

        return rawResult;
    }
}
```

### 6.2 部署配置

#### 6.2.1 appsettings.json配置
```json
{
  "MetricEngine": {
    "EnableFormulaCache": true,
    "FormulaCacheDuration": "00:10:00", // 10分钟
    "MaxFormulaLength": 1000,
    "MaxCalculationDepth": 10,
    "DefaultCalculationTimeout": "00:00:30" // 30秒
  }
}
```

## 7. 性能优化策略

### 7.1 缓存策略
1. **公式解析缓存**: 缓存解析后的表达式树
2. **计算结果缓存**: 缓存相同输入的计算结果
3. **变量值缓存**: 缓存变量解析结果

### 7.2 批量计算优化
1. **并行计算**: 使用Parallel.ForEach处理独立计算
2. **数据库批量操作**: 使用SqlSugar批量插入结果
3. **内存优化**: 分批次处理大数据集

### 7.3 监控指标
1. **计算耗时**: 记录每次计算的时间
2. **缓存命中率**: 监控缓存使用效果
3. **错误率**: 监控计算失败的比例

## 8. 安全考虑

### 8.1 公式安全
1. **沙箱环境**: 限制公式可访问的类型和方法
2. **输入验证**: 验证公式长度和复杂度
3. **资源限制**: 限制计算时间和内存使用

### 8.2 数据安全
1. **权限控制**: 基于角色的指标访问控制
2. **数据隔离**: 租户数据隔离
3. **审计日志**: 记录所有指标定义和计算操作

## 9. 阶段一交付清单

### 9.1 后端交付物
- [ ] 数据库表结构（lab_metric_definition）
- [ ] 实体类：MetricDefinitionEntity
- [ ] DTO类：MetricDefinitionInput/Query/Dto等
- [ ] 服务接口：IMetricDefinitionService
- [ ] 服务实现：MetricDefinitionService
- [ ] 公式引擎核心：FormulaParser
- [ ] API控制器集成
- [ ] 单元测试（覆盖率 > 70%）

### 9.2 前端交付物
- [ ] TypeScript类型定义
- [ ] API客户端方法
- [ ] 指标列表页面
- [ ] 指标表单页面
- [ ] 公式编辑器组件
- [ ] 计算器组件
- [ ] 单元测试

### 9.3 文档交付物
- [ ] API端点规范文档
- [ ] 技术规范文档（本文档）
- [ ] 数据库设计文档
- [ ] 部署指南

## 10. 后续阶段规划

### 10.1 阶段二（变量绑定系统）
- 变量定义和绑定管理
- 动态变量解析
- 公式版本管理
- 批量计算优化

### 10.2 阶段三（高级特性）
- 公式调试工具
- 性能监控界面
- 智能缓存策略
- JIT编译优化

### 10.3 阶段四（迁移和优化）
- 现有公式迁移
- 性能对比测试
- 生产部署方案
- 用户培训材料

---

**文档版本**: v1.0
**最后更新**: 2026-01-20
**负责人**: Claude (项目经理/架构师)
**状态**: 阶段一技术规范