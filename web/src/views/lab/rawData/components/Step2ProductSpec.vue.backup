<template>
  <div class="step2-container">
    <!-- æ­¥éª¤è¯´æ˜ -->
    <a-alert
      message="ç¬¬ä¸‰æ­¥ï¼šè‡ªåŠ¨åŒ¹é…äº§å“è§„æ ¼"
      description="ç³»ç»Ÿå·²æ ¹æ®æ£€æµ‹æ•°æ®è‡ªåŠ¨åŒ¹é…äº§å“è§„æ ¼ï¼Œè¯·æ£€æŸ¥å¹¶ä¿®æ­£åŒ¹é…ç»“æœã€‚æœªåŒ¹é…çš„æ•°æ®éœ€è¦æ‰‹åŠ¨é€‰æ‹©äº§å“è§„æ ¼ã€‚æœ¬æ­¥éª¤åªæ˜¾ç¤ºæœ‰æ•ˆæ•°æ®ã€‚"
      type="info"
      show-icon
      style="margin-bottom: 20px" />

    <!-- è°ƒè¯•ç”¨æŒ‰é’® -->
    <div style="margin-bottom: 10px; padding: 10px; background: #fffbe6; border: 1px solid #ffe58f; border-radius: 4px;">
      <span style="color: #fa8c16; margin-right: 10px;">ğŸ”§ è°ƒè¯•æ¨¡å¼</span>
      <a-button size="small" @click="() => {
        console.log('æµ‹è¯•æ‰“å¼€å¼¹çª—');
        specModalVisible.value = true;
      }">
        æµ‹è¯•å¼¹çª—
      </a-button>
      <a-button size="small" style="margin-left: 8px;" @click="() => {
        console.log('å½“å‰çŠ¶æ€:', {
          specModalVisible: specModalVisible.value,
          currentRecord: currentRecord.value,
          specList: specList.value.length
        });
      }">
        æŸ¥çœ‹çŠ¶æ€
      </a-button>
    </div>

    <!-- ç»Ÿè®¡ä¿¡æ¯ -->
    <div class="statistics-section">
      <a-row :gutter="16">
        <a-col :span="6">
          <a-statistic title="æ€»æ•°æ®è¡Œæ•°" :value="totalRows" />
        </a-col>
        <a-col :span="6">
          <a-statistic title="å·²åŒ¹é…" :value="matchedCount" :value-style="{ color: '#52c41a' }" />
        </a-col>
        <a-col :span="6">
          <a-statistic title="æœªåŒ¹é…" :value="unmatchedCount" :value-style="{ color: '#ff4d4f' }" />
        </a-col>
        <a-col :span="6">
          <a-statistic title="åŒ¹é…ç‡" :value="matchRate" suffix="%" />
        </a-col>
      </a-row>
    </div>

    <!-- ç­›é€‰å’Œæ“ä½œ -->
    <div class="filter-section">
      <a-space>
        <a-button @click="handleRefresh" :loading="loading">
          <ReloadOutlined /> åˆ·æ–°åŒ¹é…ç»“æœ
        </a-button>
        <a-button @click="handleBatchMatch" :disabled="!hasUnmatchedData">
          <ThunderboltOutlined /> æ‰¹é‡åŒ¹é…
        </a-button>
        <a-select
          v-model:value="filterStatus"
          style="width: 120px"
          placeholder="ç­›é€‰çŠ¶æ€"
          allow-clear
          @change="handleFilterChange">
          <a-select-option value="">å…¨éƒ¨</a-select-option>
          <a-select-option value="matched">å·²åŒ¹é…</a-select-option>
          <a-select-option value="unmatched">æœªåŒ¹é…</a-select-option>
        </a-select>
        <a-input-search
          v-model:value="searchText"
          placeholder="æœç´¢ç‚‰å·æˆ–äº§å“è§„æ ¼"
          style="width: 250px"
          @search="handleSearch"
          allow-clear />
      </a-space>
    </div>

    <!-- æ•°æ®è¡¨æ ¼ -->
    <div class="table-section">
      <a-table
        :columns="columns"
        :data-source="displayData"
        :pagination="paginationConfig"
        :row-selection="rowSelection"
        :loading="loading"
        row-key="id"
        size="middle"
        :scroll="{ x: 1000 }">
        <template #bodyCell="{ column, record }">
          <template v-if="column.dataIndex === 'prodDate'">
            {{ formatDate(record.prodDate) }}
          </template>
          <template v-else-if="column.dataIndex === 'furnaceNo'">
            <div class="furnace-no-cell">
              <div>{{ record.furnaceNo }}</div>
              <div v-if="record.featureSuffix" class="feature-tag">
                <a-tag size="small">{{ record.featureSuffix }}</a-tag>
              </div>
            </div>
          </template>

          <template v-else-if="column.dataIndex === 'productSpec'">
            <div class="product-spec-cell">
              <div v-if="record.productSpecId" class="matched-spec">
                <div class="spec-name">{{ record.productSpecName }}</div>
                <div class="spec-code">{{ record.productSpecCode }}</div>
              </div>
              <div v-else class="unmatched-spec">
                <a-tag color="error">æœªåŒ¹é…</a-tag>
              </div>
            </div>
          </template>

          <template v-else-if="column.dataIndex === 'detectionColumns'">
            <div class="detection-info">
              <a-tag v-if="record.detectionColumns" color="blue">
                {{ record.detectionColumns }}åˆ—
              </a-tag>
              <span v-else>-</span>
            </div>
          </template>

          <template v-else-if="column.dataIndex === 'actions'">
            <a-space>
              <a-button
                v-if="!record.productSpecId"
                type="primary"
                size="small"
                @click="(e: MouseEvent) => {
                  e.stopPropagation();
                  e.preventDefault();
                  console.log('é€‰æ‹©è§„æ ¼æŒ‰é’®è¢«ç‚¹å‡»', record);
                  handleSelectSpec(record);
                }"
                @mousedown.stop>
                <EditOutlined /> é€‰æ‹©è§„æ ¼
              </a-button>
              <a-button
                v-else
                type="link"
                size="small"
                @click="(e: MouseEvent) => {
                  e.stopPropagation();
                  e.preventDefault();
                  console.log('ä¿®æ”¹æŒ‰é’®è¢«ç‚¹å‡»', record);
                  handleSelectSpec(record);
                }"
                @mousedown.stop>
                <EditOutlined /> ä¿®æ”¹
              </a-button>
              <a-button
                type="link"
                danger
                size="small"
                @click="(e: MouseEvent) => {
                  e.stopPropagation();
                  e.preventDefault();
                  handleClearSpec(record);
                }"
                @mousedown.stop>
                <ClearOutlined /> æ¸…é™¤
              </a-button>
            </a-space>
          </template>
        </template>
      </a-table>
    </div>

    <!-- äº§å“è§„æ ¼é€‰æ‹©å¼¹çª— -->
    <a-modal
      v-model:open="specModalVisible"
      title="é€‰æ‹©äº§å“è§„æ ¼"
      :width="800"
      :mask-closable="false"
      :z-index="3000"
      :get-container="() => document.body"
      :append-to-body="true"
      wrap-class-name="spec-selection-modal"
      @ok="handleSpecModalOk"
      @cancel="handleSpecModalCancel">
      <div class="spec-selection-content">
        <!-- æœç´¢å’Œç­›é€‰ -->
        <div class="spec-filter">
          <a-space>
            <a-input-search
              v-model:value="specSearchText"
              placeholder="æœç´¢äº§å“è§„æ ¼åç§°æˆ–ç¼–ç "
              style="width: 250px"
              @search="handleSpecSearch"
              allow-clear />
            <a-select
              v-model:value="specFilterEnabled"
              style="width: 120px"
              placeholder="çŠ¶æ€"
              allow-clear
              @change="handleSpecFilterChange">
              <a-select-option :value="true">å¯ç”¨</a-select-option>
              <a-select-option :value="false">ç¦ç”¨</a-select-option>
            </a-select>
          </a-space>
        </div>

        <!-- è§„æ ¼åˆ—è¡¨ -->
        <a-table
          :columns="specColumns"
          :data-source="specList"
          :pagination="specPagination"
          :loading="specLoading"
          :row-selection="specRowSelection"
          row-key="id"
          size="small"
          @change="handleSpecTableChange">
          <template #bodyCell="{ column, record }">
            <template v-if="column.dataIndex === 'enabled'">
              <a-tag :color="record.enabled ? 'green' : 'red'">
                {{ record.enabled ? 'å¯ç”¨' : 'ç¦ç”¨' }}
              </a-tag>
            </template>

            <template v-else-if="column.dataIndex === 'detectionColumns'">
              <a-tag color="blue">{{ record.detectionColumns }}åˆ—</a-tag>
            </template>
          </template>
        </a-table>
      </div>
    </a-modal>

    <!-- æ‰¹é‡åŒ¹é…å¼¹çª— -->
    <a-modal
      v-model:open="batchMatchModalVisible"
      title="æ‰¹é‡åŒ¹é…äº§å“è§„æ ¼"
      :width="600"
      :z-index="3000"
      :get-container="() => document.body"
      :append-to-body="true"
      @ok="handleBatchMatchOk"
      @cancel="handleBatchMatchCancel">
      <p>å°†ä¸ºé€‰ä¸­çš„ {{ selectedRowKeys.length }} è¡Œæ•°æ®æ‰¹é‡è®¾ç½®äº§å“è§„æ ¼ï¼š</p>
      <a-form :model="batchMatchForm" layout="vertical">
        <a-form-item
          label="äº§å“è§„æ ¼"
          name="productSpecId"
          :rules="[{ required: true, message: 'è¯·é€‰æ‹©äº§å“è§„æ ¼' }]">
          <a-select
            v-model:value="batchMatchForm.productSpecId"
            placeholder="è¯·é€‰æ‹©äº§å“è§„æ ¼"
            show-search
            :filter-option="filterProductSpecOption">
              <a-select-option
                v-for="spec in specList"
                :key="spec.id"
                :value="spec.id"
                :disabled="!spec.enabled">
                {{ spec.name }} ({{ spec.code }})
              </a-select-option>
          </a-select>
        </a-form-item>
      </a-form>
    </a-modal>

    <!-- åŠ è½½çŠ¶æ€ -->
    <div v-if="loading" class="loading-overlay">
      <a-spin tip="æ­£åœ¨åŠ è½½æ•°æ®..." />
    </div>
  </div>
</template>

<script lang="ts" setup>
import { ref, computed, reactive, onMounted, nextTick, watch } from 'vue';
import { message } from 'ant-design-vue';
import {
  ReloadOutlined,
  ThunderboltOutlined,
  EditOutlined,
  ClearOutlined
} from '@ant-design/icons-vue';
import { getProductSpecMatches, updateProductSpecMatches } from '/@/api/lab/rawData';
import { getProductSpecList } from '/@/api/lab/productSpec';
import type {
  RawDataRow,
  ProductSpec,
  Step2ProductSpecInput
} from '/@/api/lab/types/rawData';

const props = defineProps({
  importSessionId: {
    type: String,
    required: true,
  },
});

const emit = defineEmits(['prev', 'next', 'cancel']);

// çŠ¶æ€
const loading = ref(false);
const data = ref<RawDataRow[]>([]);
const specList = ref<ProductSpec[]>([]);
const filterStatus = ref('');
const searchText = ref('');
const selectedRowKeys = ref<string[]>([]);

// å¼¹çª—çŠ¶æ€
const specModalVisible = ref(false);
const specLoading = ref(false);
const specSearchText = ref('');
const specFilterEnabled = ref();
const currentRecord = ref<RawDataRow | null>(null);
const selectedSpecKeys = ref<string[]>([]);

// æ‰¹é‡åŒ¹é…å¼¹çª—
const batchMatchModalVisible = ref(false);
const batchMatchForm = reactive({
  productSpecId: '',
});

// åˆ†é¡µé…ç½®
const paginationConfig = reactive({
  current: 1,
  pageSize: 20,
  total: 0,
  showSizeChanger: true,
  showQuickJumper: true,
  showTotal: (total: number) => `å…± ${total} æ¡`,
});

// è§„æ ¼åˆ—è¡¨åˆ†é¡µ
const specPagination = reactive({
  current: 1,
  pageSize: 10,
  total: 0,
  showSizeChanger: true,
  showQuickJumper: true,
});

// è®¡ç®—å±æ€§
const totalRows = computed(() => data.value.length);
const matchedCount = computed(() => data.value.filter(row => row.productSpecId).length);
const unmatchedCount = computed(() => data.value.filter(row => !row.productSpecId).length);
const matchRate = computed(() => totalRows.value > 0 ? Math.round((matchedCount.value / totalRows.value) * 100) : 0);
const hasUnmatchedData = computed(() => unmatchedCount.value > 0);

const displayData = computed(() => {
  // ç¡®ä¿ data.value æ˜¯æ•°ç»„
  if (!Array.isArray(data.value)) {
    return [];
  }

  let filtered = data.value;

  // çŠ¶æ€ç­›é€‰
  if (filterStatus.value === 'matched') {
    filtered = filtered.filter(row => row.productSpecId);
  } else if (filterStatus.value === 'unmatched') {
    filtered = filtered.filter(row => !row.productSpecId);
  }

  // æœç´¢ç­›é€‰
  if (searchText.value) {
    const search = searchText.value.toLowerCase();
    filtered = filtered.filter(row =>
      row.furnaceNo?.toLowerCase().includes(search) ||
      (row.productSpecName && row.productSpecName.toLowerCase().includes(search)) ||
      (row.productSpecCode && row.productSpecCode.toLowerCase().includes(search))
    );
  }

  // åˆ†é¡µ
  paginationConfig.total = filtered.length;
  const start = (paginationConfig.current - 1) * paginationConfig.pageSize;
  const end = start + paginationConfig.pageSize;
  return filtered.slice(start, end);
});

// è¡¨æ ¼åˆ—é…ç½®
const columns = [
  {
    title: 'è¡Œå·',
    dataIndex: 'rowIndex',
    width: 80,
    fixed: 'left',
  },
  {
    title: 'ç”Ÿäº§æ—¥æœŸ',
    dataIndex: 'prodDate',
    width: 120,
  },
  {
    title: 'ç‚‰å·',
    dataIndex: 'furnaceNo',
    width: 180,
  },
  {
    title: 'å®½åº¦',
    dataIndex: 'width',
    width: 100,
    align: 'center',
  },
  {
    title: 'å¸¦æé‡é‡',
    dataIndex: 'coilWeight',
    width: 120,
    align: 'center',
  },
  {
    title: 'æ£€æµ‹åˆ—æ•°',
    dataIndex: 'detectionColumns',
    width: 100,
    align: 'center',
  },
  {
    title: 'äº§å“è§„æ ¼',
    dataIndex: 'productSpec',
    width: 200,
  },
  {
    title: 'æ“ä½œ',
    dataIndex: 'actions',
    width: 150,
    fixed: 'right',
  },
];

// è§„æ ¼è¡¨æ ¼åˆ—é…ç½®
const specColumns = [
  {
    title: 'è§„æ ¼ç¼–ç ',
    dataIndex: 'code',
    width: 120,
  },
  {
    title: 'è§„æ ¼åç§°',
    dataIndex: 'name',
    width: 200,
  },
  {
    title: 'æ£€æµ‹åˆ—æ•°',
    dataIndex: 'detectionColumns',
    width: 100,
    align: 'center',
  },
  {
    title: 'çŠ¶æ€',
    dataIndex: 'enabled',
    width: 80,
    align: 'center',
  },
];

// è¡¨æ ¼è¡Œé€‰æ‹©é…ç½®
const rowSelection = computed(() => ({
  selectedRowKeys: selectedRowKeys.value,
  onChange: (keys: string[]) => {
    selectedRowKeys.value = keys;
  },
}));

// è§„æ ¼è¡¨æ ¼è¡Œé€‰æ‹©
const specRowSelection = computed(() => ({
  type: 'radio' as const,
  selectedRowKeys: selectedSpecKeys.value,
  onChange: (keys: string[]) => {
    selectedSpecKeys.value = keys;
    if (keys.length > 0) {
      const spec = specList.value.find(s => s.id === keys[0]);
      if (spec && currentRecord.value) {
        currentRecord.value.productSpecId = spec.id;
        currentRecord.value.productSpecCode = spec.code;
        currentRecord.value.productSpecName = spec.name;
        currentRecord.value.detectionColumns = spec.detectionColumns;
      }
    }
  },
}));

// æ–¹æ³•
async function loadData() {
  loading.value = true;
  try {
    const response = await getProductSpecMatches(props.importSessionId);
    
    // ç¡®ä¿è¿”å›çš„æ˜¯æ•°ç»„
    let result = response;
    if (response && typeof response === 'object' && !Array.isArray(response)) {
      // å¦‚æœè¿”å›çš„æ˜¯å¯¹è±¡ï¼Œå°è¯•è·å– data æˆ– list å±æ€§
      result = response.data || response.list || response.items || [];
    }
    
    // ç¡®ä¿æ˜¯æ•°ç»„
    if (!Array.isArray(result)) {
      result = [];
    }
    
    // è½¬æ¢æ•°æ®æ ¼å¼ï¼šåç«¯è¿”å›çš„æ˜¯ RawDataProductSpecMatchOutputï¼Œéœ€è¦è½¬æ¢ä¸º RawDataRow
    data.value = result.map((item: any) => ({
      id: item.rawDataId || item.id || item.RawDataId,
      furnaceNo: item.furnaceNo || item.FurnaceNo,
      prodDate: item.prodDate || item.ProdDate,
      width: item.width || item.Width,
      coilWeight: item.coilWeight || item.CoilWeight,
      detectionColumns: item.detectionColumns || item.DetectionColumns,
      productSpecId: item.productSpecId || item.ProductSpecId,
      productSpecName: item.productSpecName || item.ProductSpecName,
      productSpecCode: item.productSpecCode || item.ProductSpecCode,
      productSpecMatchStatus: item.matchStatus || item.MatchStatus,
      rowIndex: 0, // å°†åœ¨ä¸‹é¢è®¾ç½®
    }));

    // æ·»åŠ è¡Œå·
    data.value.forEach((row, index) => {
      row.rowIndex = index + 1;
    });

    // è®¾ç½®é€‰ä¸­è¡Œ
    selectedRowKeys.value = data.value
      .filter(row => !row.productSpecId)
      .map(row => row.id!)
      .filter(id => id); // è¿‡æ»¤æ‰ undefined/null
  } catch (error) {
    console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
    message.error('åŠ è½½æ•°æ®å¤±è´¥');
    data.value = []; // ç¡®ä¿å¤±è´¥æ—¶ä¹Ÿæ˜¯ç©ºæ•°ç»„
  } finally {
    loading.value = false;
  }
}

async function loadProductSpecs() {
  // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œé¿å…é‡å¤è¯·æ±‚
  if (specLoading.value) {
    return;
  }
  
  specLoading.value = true;
  try {
    const response = await getProductSpecList({
      page: specPagination.current,
      pageSize: specPagination.pageSize,
      keyword: specSearchText.value,
      enabled: specFilterEnabled.value,
    });
    specList.value = response.list || [];
    specPagination.total = response.total || 0;
  } catch (error) {
    console.error('åŠ è½½äº§å“è§„æ ¼å¤±è´¥:', error);
    message.error('åŠ è½½äº§å“è§„æ ¼å¤±è´¥');
    specList.value = [];
    specPagination.total = 0;
  } finally {
    specLoading.value = false;
  }
}

function handleRefresh() {
  loadData();
}

function handleBatchMatch() {
  if (selectedRowKeys.value.length === 0) {
    message.warning('è¯·å…ˆé€‰æ‹©è¦æ‰¹é‡åŒ¹é…çš„æ•°æ®');
    return;
  }
  batchMatchModalVisible.value = true;
}

function handleFilterChange() {
  paginationConfig.current = 1;
}

function handleSearch() {
  paginationConfig.current = 1;
}

async function handleSelectSpec(record: RawDataRow) {
  console.log('handleSelectSpec è¢«è°ƒç”¨', record);

  if (!record) {
    console.error('record is null or undefined');
    message.error('æœªæ‰¾åˆ°æ•°æ®è®°å½•');
    return;
  }

  try {
    // å…ˆè®¾ç½®å½“å‰è®°å½•
    currentRecord.value = record;
    console.log('å½“å‰è®°å½•å·²è®¾ç½®:', currentRecord.value);

    // å¦‚æœè®°å½•å·²æœ‰äº§å“è§„æ ¼ï¼Œé¢„é€‰ä¸­è¯¥è§„æ ¼
    if (record.productSpecId) {
      selectedSpecKeys.value = [record.productSpecId];
      console.log('é¢„é€‰ä¸­å·²æœ‰è§„æ ¼:', record.productSpecId);
    } else {
      selectedSpecKeys.value = [];
      console.log('æ¸…ç©ºé€‰ä¸­è§„æ ¼');
    }

    // å¼ºåˆ¶æ‰“å¼€å¼¹çª— - ä½¿ç”¨ setTimeout ç¡®ä¿çŠ¶æ€æ›´æ–°
    setTimeout(() => {
      specModalVisible.value = true;
      console.log('å¼¹çª—å¯è§æ€§å·²è®¾ç½®ä¸º true (ä½¿ç”¨setTimeout)');

      // å¼ºåˆ¶æ£€æŸ¥DOM
      setTimeout(() => {
        const modalElement = document.querySelector('.spec-selection-modal');
        console.log('å¼¹çª—DOMå…ƒç´ æ£€æŸ¥:', modalElement);
        if (!modalElement) {
          console.warn('æœªæ‰¾åˆ°å¼¹çª—DOMå…ƒç´ ï¼Œå¯èƒ½æ˜¯z-indexæˆ–æ¸²æŸ“é—®é¢˜');
        }
      }, 100);
    }, 0);

    // ç­‰å¾…å¼¹çª—æ¸²æŸ“å®Œæˆåå†åŠ è½½æ•°æ®ï¼Œé¿å…é˜»å¡UI
    await nextTick();
    console.log('nextTick å®Œæˆ');

    // å¦‚æœè§„æ ¼åˆ—è¡¨ä¸ºç©ºï¼Œæ‰åŠ è½½æ•°æ®ï¼ˆé¿å…é‡å¤åŠ è½½ï¼‰
    if (specList.value.length === 0) {
      console.log('è§„æ ¼åˆ—è¡¨ä¸ºç©ºï¼Œå¼€å§‹åŠ è½½...');
      // å¼‚æ­¥åŠ è½½äº§å“è§„æ ¼åˆ—è¡¨ï¼Œä¸é˜»å¡å¼¹çª—æ˜¾ç¤º
      loadProductSpecs().catch(error => {
        console.error('åŠ è½½äº§å“è§„æ ¼å¤±è´¥:', error);
      });
    } else {
      // å¦‚æœå·²æœ‰æ•°æ®ï¼Œç¡®ä¿é€‰ä¸­çŠ¶æ€æ­£ç¡®
      await nextTick();
      console.log('å·²æœ‰è§„æ ¼åˆ—è¡¨æ•°æ®');
    }
  } catch (error) {
    console.error('Error in handleSelectSpec:', error);
    message.error('æ‰“å¼€è§„æ ¼é€‰æ‹©å¼¹çª—å¤±è´¥');
    specModalVisible.value = false;
  }
}

function handleClearSpec(record: RawDataRow) {
  record.productSpecId = '';
  record.productSpecCode = '';
  record.productSpecName = '';
  record.detectionColumns = '';
}

function handleSpecSearch() {
  specPagination.current = 1;
  loadProductSpecs();
}

function handleSpecFilterChange() {
  specPagination.current = 1;
  loadProductSpecs();
}

function handleSpecTableChange(pagination: any) {
  specPagination.current = pagination.current;
  specPagination.pageSize = pagination.pageSize;
  loadProductSpecs();
}

async function handleSpecModalOk() {
  if (!currentRecord.value?.productSpecId) {
    message.warning('è¯·é€‰æ‹©äº§å“è§„æ ¼');
    return;
  }
  specModalVisible.value = false;
  currentRecord.value = null;
  selectedSpecKeys.value = [];
}

function handleSpecModalCancel() {
  specModalVisible.value = false;
  currentRecord.value = null;
  selectedSpecKeys.value = [];
}

async function handleBatchMatchOk() {
  if (!batchMatchForm.productSpecId) {
    message.warning('è¯·é€‰æ‹©äº§å“è§„æ ¼');
    return;
  }

  const spec = specList.value.find(s => s.id === batchMatchForm.productSpecId);
  if (!spec) return;

  const updateData: Step2ProductSpecInput = {
    importSessionId: props.importSessionId,
    matches: selectedRowKeys.value.map(id => ({
      rowId: id,
      productSpecId: spec.id,
    })),
  };

  await updateProductSpecMatches(props.importSessionId, updateData);

  // æ›´æ–°æœ¬åœ°æ•°æ®
  data.value.forEach(row => {
    if (row.id && selectedRowKeys.value.includes(row.id)) {
      row.productSpecId = spec.id;
      row.productSpecCode = spec.code;
      row.productSpecName = spec.name;
      row.detectionColumns = spec.detectionColumns;
    }
  });

  message.success('æ‰¹é‡åŒ¹é…æˆåŠŸ');
  batchMatchModalVisible.value = false;
}

function handleBatchMatchCancel() {
  batchMatchModalVisible.value = false;
}

function filterProductSpecOption(input: string, option: any) {
  const text = option.children?.[0]?.text || '';
  return text.toLowerCase().includes(input.toLowerCase());
}

// æ ¼å¼åŒ–æ—¥æœŸ
function formatDate(date: string | number | Date | undefined) {
  if (!date) return '-';
  try {
    let d: Date;
    // å¤„ç†æ—¶é—´æˆ³ï¼ˆå¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–æ•°å­—ï¼‰
    if (typeof date === 'number' || (typeof date === 'string' && /^\d+$/.test(date))) {
      const timestamp = typeof date === 'string' ? parseInt(date, 10) : date;
      // åˆ¤æ–­æ˜¯ç§’çº§è¿˜æ˜¯æ¯«ç§’çº§æ—¶é—´æˆ³
      d = new Date(timestamp > 1000000000000 ? timestamp : timestamp * 1000);
    } else if (date instanceof Date) {
      d = date;
    } else {
      d = new Date(date);
    }
    
    if (isNaN(d.getTime())) return String(date);
    
    const year = d.getFullYear();
    const month = d.getMonth() + 1;
    const day = d.getDate();
    // æ ¼å¼: YYYY/M/D
    return `${year}/${month}/${day}`;
  } catch {
    return String(date);
  }
}

async function handlePrev() {
  emit('prev');
}

async function handleNext() {
  if (unmatchedCount.value > 0) {
    message.warning(`è¿˜æœ‰ ${unmatchedCount.value} è¡Œæ•°æ®æœªåŒ¹é…äº§å“è§„æ ¼ï¼Œè¯·å…ˆå¤„ç†`);
    return;
  }

  try {
    // ä¿å­˜å½“å‰åŒ¹é…ç»“æœ
    const updateData: Step2ProductSpecInput = {
      importSessionId: props.importSessionId,
      matches: data.value.map(row => ({
        rowId: row.id,
        productSpecId: row.productSpecId || '',
      })),
    };

    await updateProductSpecMatches(props.importSessionId, updateData);
    emit('next');
  } catch (error) {
    message.error('ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•');
  }
}

function handleCancel() {
  emit('cancel');
}

// è®¡ç®—æ˜¯å¦å¯ä»¥è¿›å…¥ä¸‹ä¸€æ­¥
const canGoNext = computed(() => {
  // æ‰€æœ‰æ•°æ®éƒ½å·²åŒ¹é…äº§å“è§„æ ¼
  return data.value.length > 0 && unmatchedCount.value === 0;
});

// ä¿å­˜å¹¶è¿›å…¥ä¸‹ä¸€æ­¥ï¼ˆä¾›çˆ¶ç»„ä»¶è°ƒç”¨ï¼‰
async function saveAndNext() {
  await handleNext();
}

// ç›‘å¬å¼¹çª—å¯è§æ€§å˜åŒ–
watch(specModalVisible, (newVal) => {
  console.log('è§„æ ¼é€‰æ‹©å¼¹çª—å¯è§æ€§å˜åŒ–:', newVal);
  console.log('å¼¹çª—DOMå…ƒç´ :', document.querySelector('.spec-selection-modal'));
});

// ç›‘å¬å½“å‰è®°å½•å˜åŒ–
watch(currentRecord, (newVal) => {
  console.log('å½“å‰è®°å½•å˜åŒ–:', newVal);
});

// ç›‘å¬é€‰ä¸­è§„æ ¼å˜åŒ–
watch(selectedSpecKeys, (newVal) => {
  console.log('é€‰ä¸­è§„æ ¼å˜åŒ–:', newVal);
});

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  loadData();
});

// æš´éœ²ç»™çˆ¶ç»„ä»¶
defineExpose({
  canGoNext,
  saveAndNext,
});
</script>

<style lang="less" scoped>
.step2-container {
  padding: 0;
}

.statistics-section {
  padding: 20px;
  background: #fafafa;
  border-radius: 8px;
  margin-bottom: 20px;
}

.filter-section {
  margin-bottom: 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.table-section {
  .furnace-no-cell {
    .feature-tag {
      margin-top: 4px;
    }
  }

  .product-spec-cell {
    .matched-spec {
      .spec-name {
        font-weight: 500;
        margin-bottom: 4px;
      }
      .spec-code {
        font-size: 12px;
        color: #8c8c8c;
      }
    }
  }

  .detection-info {
    text-align: center;
  }

  // ç¡®ä¿æ“ä½œæŒ‰é’®å¯ä»¥æ­£å¸¸ç‚¹å‡»
  :deep(.ant-table-cell-fix-right) {
    position: relative;
    z-index: 10;
    
    .ant-space {
      pointer-events: auto;
      position: relative;
      z-index: 11;
      
      .ant-btn {
        pointer-events: auto;
        cursor: pointer;
        position: relative;
        z-index: 12;
        user-select: none;
        
        &:hover {
          z-index: 13;
        }
      }
    }
  }
  
  // ç¡®ä¿å›ºå®šåˆ—ä¸ä¼šé®æŒ¡æŒ‰é’®
  :deep(.ant-table-cell-fix-right-first) {
    z-index: 10;
  }
}

.spec-selection-content {
  .spec-filter {
    margin-bottom: 16px;
  }
}

:deep(.ant-table-row:hover) {
  .product-spec-cell {
    .unmatched-spec {
      color: #1890ff;
    }
  }
}

// ç¡®ä¿è§„æ ¼é€‰æ‹©å¼¹çª—åœ¨æœ€ä¸Šå±‚
:deep(.spec-selection-modal) {
  z-index: 3000 !important;

  .ant-modal {
    z-index: 3001 !important;
  }

  .ant-modal-mask {
    z-index: 3000 !important;
  }

  .ant-modal-wrap {
    z-index: 3001 !important;
  }
}

// å…¨å±€æ ·å¼ç¡®ä¿æ¨¡æ€æ¡†åœ¨æœ€ä¸Šå±‚
:global(.ant-modal-root) {
  .ant-modal-mask {
    z-index: 3000 !important;
  }

  .ant-modal-wrap {
    z-index: 3001 !important;
  }

  .ant-modal {
    z-index: 3002 !important;
  }
}
</style>